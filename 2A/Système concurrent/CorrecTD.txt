METHODE

Moniteur -> implanter un objet partag√©
| ‚îî-> m√©thodes -> ind√©pendantes du code de l'utilisateur.ice
‚îî-> maintient de l'invariant (√©tat de l'objet

0: D√©finir le ou les objet(s) partag√©(s) (entre moniteur et utilisateur.ices)
1: Interface moniteur
   | d√©but action
   |  Action
   | fin action
2: D√©finir les pr√©dicats d'acceptation
 -> Quand est-ce que je peux r√©aliser cette action SANS DEVOIR ATTENDRE?
3: D√©duire les variables d'√©tat qui aident √† traduire les pr√©dicats
4: Traduire 2 avec 3 (+ d√©finir l'invariant avec 3)
5: D√©finir les variables conditions
  = √©v√®nements √† attendre/signaler
6: Ecrire les m√©thodes
  SI ma condition d'acceptation est fausse
    VC.attendre()
  SINON
    [√©tats des variables d'√©tat]
     (Quels pr√©dicats ok?)
    VCbis.signaler()



EX1:
Probl√®me du barbier

0: Objet partag√©: 
  La chaise (partag√© entre barbier et clients (barbier/barbier & client/client))
  La salle d'attente
  La barbe

1: Interface moniteur: 
   | Client {
   |  entrer dans la salle d'attente (ESA)
   |  s'asseoir sur le fauteuil      (AF)
   |  se lever et partir             (LP)
   | }
   
   | Barbier { (on a d√©buter/finir car le rasage est une action bloquante)
   |  d√©buter rasage                 (DR)
   |  terminer rasage                (TR)
   | }

2: Pr√©dicats d'acceptation
Client
 ESA: salle d'attente !pleine
 AF: fauteuil vide
 LP: plus de barbe

Barbier
 DR: client dans fauteuil & barbe
 TR: ‚àÖ

3: Variables d'√©tat traduisant les pr√©dicats
 ESA: ‚í∂ entier Places Libres (‚â§ N)
 AF:  ‚í∑ bool√©en fauteuil (vrai quand vide)
 LP:  ‚í∏ bool√©en barbe (vrai quand ras√©e)
 DR:  ‚í∑ et ‚í∏
 TR:  ‚àÖ

4: Traduire 2 avec 3 (+ d√©finir l'invariant avec 3)
  ESA: ‚í∂ > 0
  AF: ‚í∑
  LP: ‚í∏
  DR: !‚í∑ & !‚í∏ simplifiable en !‚í∏ (car !‚í∑ -> !‚í∏ (peu ou prou: si la barbe n'est pas ras√©e, il y a qqn dans le si√®ge!))
  TR: ‚àÖ

5: Variables conditions (√©v√©nements attente/signal)
  ESA: SalleLibre 
  AF: FauteuilLibre
  LP: BarbeRas√©e
  DR: BarbePr√©sente

6: Ecrire m√©thodes (ici on a invers√© l'ordre de la logique, pour le m√™me r√©sultat, mais apparence ‚â†)
ESA: {
  SI !(‚í∂ > 0) ALORS
    SalleLibre.attendre()  (bloquage)
  ‚í∂--
 [‚àÖ]
}

AF: {
  SI !‚í∑ ALORS
    FauteuilLibre.attendre()   (bloquage)
  ‚í∂++
  ‚í∑=false
  ‚í∏=false
  [‚í∂>0 & (!‚í∑ & !‚í∏)]
  SalleLibre.signaler()
  BarbePr√©sente.Signaler()
}

LP: {
  SI !‚í∏ ALORS
    BarbeRas√©e.attendre()  (bloquage)
  ‚í∑=true
  [‚í∑]
  FauteuilLibre.signaler()
}

DR: {
  SI ‚í∑ | ‚í∏ ALORS    ( !(!‚í∑ & !‚í∏) est ‚í∑ | ‚í∏ ) (simplifiable en ‚í∏)
    BarbePr√©sente.attendre()
  [‚àÖ]
}

TR: {
  ‚í∏=true
  [‚í∏]
  BarbeRas√©e.signaler()
}


Pour le cas o√π un client abandonne si la salle d'attente est pleine: on peut modifier le script ESA comme suit:
ESA: {
  SI !(‚í∂ > 0) ALORS
    ABANDON
  ‚í∂--
 [‚àÖ]
}

Pour le cas o√π il y a plusieurs barbiers: ils faudra des compteurs fauteuil et barbe, et modifier certains scripts. (Non pr√©sent√© ici)





Ex2:
On aura plusieurs lecteurs en ||, un seul r√©dacteur √† la fois.
Si r√©dacteur, pas de lecteur, et vice-versa
Les lecteurs sont prioritaires en attente (si lecteur & r√©dacteur en attente, lecteur passe)

0: Objet partag√©: 
Une M√©moire partag√©e

1: Interface moniteur: 
On a d'apr√®s l'√©nonc√©, l'interface
  D√©buter_Lecture   (DL)
  Terminer_Lecture  (TL)
  D√©buter_Ecriture  (DE)
  Terminer_Ecriture (TE)

2: Pr√©dicats d'acceptation
  DL: Pas d'√©criture en cours
  TL: ‚àÖ
  DE: Pas de lecture ni d'√©criture en cours, ni de lecteur en attente
  TE: ‚àÖ

3: Variables d'√©tat traduisant les pr√©dicats
 DL: ‚í∂ bool√©en r√©daction
 TL: ‚àÖ
 DE: ‚í∂, ‚í∑ entier nombre lecteurs et ‚í∏ entier nombre lecteurs en attente
 TE: ‚àÖ

4: Traduire 2 avec 3 (+ d√©finir l'invariant avec 3)
 DL: !‚í∂
 TL: ‚àÖ
 DE: !‚í∂ & ‚í∑ = 0 & ‚í∏ = 0
 TE: ‚àÖ

5: Var condition
 LectureOk
 EcritureOk


6: Ecrire m√©thodes
DL: {
  SI ‚í∂ ALORS   (!(!‚í∂) = ‚í∂)
    ‚í∏++
    LectureOk.attendre()
  ‚í∏--
  ‚í∑++
   
  {‚í∑>0 & !‚í∂}
  LectureOk.signaler()  (r√©veil en chaine: la fin de l'ecriture r√©veille un lecteur qui √† son tour r√©veille un autre lecteur...)
}

TL: {
  ‚í∑--
  {‚í∑‚â•0 & !‚í∂}

  SI ‚í∑ = 0 & ‚í∏ = 0 ALORS
    EcritureOk.signaler()
  SINON
    LectureOk.signaler()
}

DE: {
  SI ‚í∂ | ‚í∑ > 0 | ‚í∏ > 0 ALORS    (inversion de logique... (simplification de !x, implicite par la suite))
    EcritureOk.attendre()
  ‚í∂ = true
   
  {‚í∂ & ‚í∑ = 0}   (‚í∏ ‚â• 0 car des lecteurs auront pu arriver en attente entre temps)
}

TE: {
  ‚í∂ = false
  {!‚í∂ & ‚í∑ = 0}  (‚í∏ ‚â• 0)

  SI ‚í∏ = 0 ALORS
    EcritureOk.signaler()
  SINON
    LectureOk.signaler()
}


Rappel structure √©tape 6:
SI non (condtionAcceptation) ALORS
  VC.attendre()

(Mettre √† jour var. d'√©tat)
[etat des variables d'etat]
 -> signaler les VCs correspondantes



On fait la m√™me chose, avec strat√©gie FIFO (on rappelle que les variables conditions agissent comme des files (attendre permet de rentrer dans la file, signaler fait passer le premier de la file)

0: inchang√©
1: inchang√©
2: Pr√©dicats d'acceptation
  DL: Pas de r√©dacteur ET file vide
  TL: ‚àÖ
  DE: Pas de r√©dacteur ni lecteur ET file vide
  TE: ‚àÖ
3: Variables d'√©tat traduisant les pr√©dicats
 DL: ‚í∂ bol√©en r√©daction & AccesOk.vide() bool√©en li√© √† une variable condition  
 TL: ‚àÖ
 DE: ‚í∂ & ‚í∑ entier nombre lecteurs & AccesOk.vide() 
 TE: ‚àÖ

4: Traduire 2 avec 3 (+ d√©finir l'invariant avec 3)
 DL: !‚í∂ & AccesOk.vide()
 TL: ‚àÖ
 DE: !‚í∂ & ‚í∑ = 0 & AccesOk.vide()
 TE: ‚àÖ

5: Var condition
 AccesOk (lecture/ecriture Ok)

6: Ecrire m√©thodes
DL: {
  SI ‚í∂ | !AccesOk.vide() ALORS
    AccesOk.attendre()
  
  ‚í∑++
  {‚í∑>0 & !‚í∂}
  AccesOK.signaler()  
}

TL: {
  ‚í∑--
  {‚í∑‚â•0 & !‚í∂}
  AccesOk.signaler()
}

DE: {
  SI ‚í∂ | ‚í∑ > 0 | AccesOk.vide() ALORS
    AccesOk.attendre()
  ‚í∂=true
   
  {‚í∂ & ‚í∑ = 0} 
}

TE: {
  ‚í∂ = false
  {!‚í∂ & ‚í∑ = 0}

  AccesOk.signaler()
}

On remarque que ce mod√®le permet √† un r√©dacteur de se lancer m√™me si des lecteurs sont d√©j√† pr√©sents. On le modifie donc.

0: inchang√©
1: inchang√©
2: inchang√©

3: Variables d'√©tat traduisant les pr√©dicats
 DL: ‚í∂ bol√©en r√©daction & AccesOk.vide() bool√©en li√© √† une variable condition & Sas.vide()
 TL: ‚àÖ
 DE: ‚í∂ & ‚í∑ entier nombre lecteurs & AccesOk.vide() 
 TE: ‚àÖ

4: Traduire 2 avec 3 (+ d√©finir l'invariant avec 3)
 DL: !‚í∂ & AccesOk.vide() & Sas.vide()
 TL: ‚àÖ
 DE: !‚í∂ & ‚í∑ = 0 & AccesOk.vide()
 TE: ‚àÖ

5: Var condition
 AccesOk (lecture/ecriture Ok)
 Sas (bloque quand un r√©dacteur est en t√™te)

6: M√©thodes
DL: {
  SI ‚í∂ | !AccesOk.vide() |¬†!Sas.vide() ALORS
    AccesOk.attendre()
  
  ‚í∑++
  {‚í∑>0 & !‚í∂ & Sas.vide()}
  
  AccesOK.signaler()  
}

TL: {
  ‚í∑--
  {‚í∑‚â•0 & !‚í∂}

  SI Sas.vide() ALORS
    AccesOK.signaler()
   
  SI ‚í∑ = 0 ALORS
    Sas.signaler()
}

DE: {
  SI ‚í∂ | ‚í∑ > 0 | !AccesOk.vide() ALORS
    AccesOk.attendre()

  SI ‚í∑ > 0 ALORS
    Sas.attendre()
  ‚í∂=true
   
  {‚í∂ & ‚í∑ = 0 & Sas.vide()} 
}

TE: {
  ‚í∂ = false
  {!‚í∂ & ‚í∑ = 0 & Sas.vide()}

  AccesOk.signaler()
}




EX3: Non r√©alis√© en TD, √† faire de son cot√©.
Si besoin de correction contacter la prof: sophie.mouron@etu.toulouse-inp.fr



TD CSP - CLIENT SERVEUR


Protocole sans m√©moire partag√©e:
| ‚îî‚ü∂ On fonctionne par √©change de messages via des canaux avec le serveur
‚îî‚ü∂ Pas de gestion de conflits n√©cessaire.

Syntaxe CSP:  ‚îå‚ü∂ message retir√©
‚îú‚ü∂ nom_canal?_ = on retire un message sur le canal  | RDV
‚îî‚ü∂ nom_canal!_ = on d√©pose un message sur le canal  |
              ‚îî‚ü∂ message d√©pos√©

Processus communs (en concurrence)
loop
‚îÇd√©poser sur le canal 1
‚îÇtraiter
‚îÇretirer sur le canal 2

Processus Serveur
loop
‚îÇcondition d'acceptation 1 -> rq1
‚îÇüûé
‚îÇcondition d'acceptation 2 -> rq2



Serveur:
‚îú‚ü∂ Conditions d'acceptation √©valu√©es une fois -> "supprime" les branches
‚îÇ fausses pour l'it√©ration
‚îú‚ü∂ Choix arbitraire de la requ√™te si plusieurs en attente
‚îî‚ü∂ Se bloque en attente d'une requ√™te si aucune n'est en attente.


Notre d√©marche est identique √† celle des moniteurs (l'implantation change!):

                                  ‚îå‚ü∂ Un canal pour les entr√©es par m√©thode
     ‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì       ‚îÇ     ‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î∏‚îÄ                   ‚îÉ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÉ                    ‚îÉ
‚îÇM√©thode 1                ‚îÉ  ‚ïê‚ï°Canal 1‚ïû‚ïê‚ï™                    ‚îÉ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î∞‚îÄ                   ‚îÉ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÉ                    ‚îÉ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î∏‚îÄ                   ‚îÉ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÉ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÉ
‚îÇM√©thode 2 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÉ  ‚ïê‚ï°Canal 2‚ïû‚ïê‚ï™     ‚îÇObjet partag√©‚îÇ‚îÉ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î∞‚îÄ    ‚îÇObjet partag√©‚îÇ‚îÉ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÉ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÉ
     ‚îÉ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÉ       ‚îÇ     ‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ
     ‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ       ‚îî‚ü∂ Un canal pour les sorties par m√©thode      
         Moniteurs                         

On a les √©tapes:
1- Interface
2- Conditions d'acceptation
3- Variables d'√©tat
 - Traduction des CA en language math√©matique
4- Canaux






Exercice 4: Voie unique
1- Interface
Code train: *[entrer!dir; sortir!_]

Processus train:
loop
‚îÇ Entrer()
‚îÇ voyager
‚îÇ Sortir()

2- Conditions d'acceptation
  Sortir!_: ‚àÖ
  Entrer!dir: soit la voie est libre, soit dir = dir_courante

!!Ce mod√®le ne marche pas car on ne connait pas dir avant de r√©cup√©rer entr√©e. (Puisque dir est contenu dans entr√©e)

1- Interface
Code train: *[entrerEO!_; sortir!_; entrerOE!_; sortir!_]

(Processus train ouest et train est)

2- Conditions d'acceptation
  Sortir!_: ‚àÖ
  entrerEO!_: soit la voie est libre, soit dirCourante = EO
  entrerOE!_: soit la voie est libre, soit dirCourante = OE

3- Variables d'√©tat
  int NbTrain: Nombre de trains sur la voie unique
  dir dirCourante: Direction courante, avec: enum dir { EO, OE }

 - Traduction des CA en language math√©matique
  Sortir!_: ‚àÖ
  entrerEO!_: NbTrain = 0 | dirCourante = EO
  entrerOE!_: NbTrain = 0 | dirCourante = OE


4- Canaux
Serveur:
code aiguilleur
*[ #on rappelle que le serveur √©value tous les cas, et execute tous celui qui est vrai (si plusieurs vrai 
  (NbTrain = 0 | dirCourante = EO) -> { #cas 1
    entrerEO?_        #on accepte un train allant d'est vers ouest
    NbTrain++         #on compte
    dirCourante = EO  #on met a jour la direction
  }
  üûé  #on rappelle que le serveur √©value tous les cas, et execute tous celui qui est vrai (si plusieurs vrai, il en ex√©cute un arbitrairement). Ce symbole repr√©sente un "ou".
  (NbTrain = 0 | dirCourante = OE) -> { #cas 2
    entrerOE?_        #on accepte un train allant d'ouest vers est
    NbTrain++ 
    dirCourante = OE
  }
  üûé
  Sortir?_ -> NbTrain--;
]



On a fait une version similaire aux moniteurs, on fait maintenant un version avec des automates.

 ‚îå‚îêEntrerOE
 ‚îä‚á£nbt++                ‚Üì
‚ï≠‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ    EntreEO ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ          ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ      ‚îÇ‚§é‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚î§      ‚îÇ  EntreOE ‚îÇ      ‚îú‚îà‚îà‚îê EntrerOE
‚îÇOccup√©‚îÇ     nbt=1  ‚îÇ      ‚îú‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚§è‚îÇOccup√©‚îÇ‚§é‚îò   nbt++
‚îÇ      ‚îÇ            ‚îÇ      ‚îÇ   nbt=1  ‚îÇ      ‚îÇ
‚îÇ      ‚îÇ            ‚îÇ Libre‚îÇ          ‚îÇ      ‚îÇ
‚îÇ  EO  ‚îÇ    sortir  ‚îÇ      ‚îÇ  sortir  ‚îÇ  OE  ‚îú‚îà‚îà‚îê sortir
‚îÇ      ‚îú‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚§è‚îÇ      ‚îÇ‚§é‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚î§      ‚îÇ‚§é‚îò  si nbt>1       
‚ï∞‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ   si nbt=1 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ si nbt=1 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ      nbt--
 ‚îä‚á°sortir    nbt=0             nbt=0
 ‚îî‚îònbt--


*[
  Etat=Libre    -> [{ EntrerOE?_; NbTrain=1; Etat=Occup√©OE }
                     üûé
                    { EntrerEO?_; NbTrain=1; Etat=Occup√©EO }]
  üûé
  Etat=Occup√©EO -> [{ EntrerEO?_; NbTrain++ }
                     üûé
                    { Sortir?_; NbTrain--; IF NbTrain = 0 THEN Etat = Libre }]
  üûé
  Etat=Occup√©OE -> [{ EntrerOE?_; NbTrain++ }
                     üûé
                    { Sortir?_; NbTrain--; IF NbTrain = 0 THEN Etat = Libre }]
]




Exercice 5: Tournoi de bridge (On assume un nombre infini de tables)
1- Interface 
  Entrer!_
  Sortir!_

Processus joueur:
loop
‚îÇ Entrer()
‚îÇ jouer
‚îÇ Sortir()  

Options possibles:
  Entr√©es 4 par 4 
  Sorties 4 par 4
  Une Entr√©e et Une Sortie 

On a alors un probl√®me: si le serveur doit surveiller le nombre d'entr√©es, on fait de l'attente active! (Il nous faudrait au moins un √©tat sans conditions)


1- Interface
  DemanderEntrer!_ 
  DemanderSortir!_
  Entrer!_
  Sortir!_

Processus joueur:
loop
‚îÇ demanderEntrer() #le serveur ne bloque jamais, mais ca lui permet de compter les entrees.
‚îÇ Entrer()         #bloquant
‚îÇ jouer
‚îÇ demanderSortir() #le serveur ne bloque jamais, mais ca lui permet de compter les sorties.
‚îÇ Sortir()         #bloquant

2- Conditions d'acceptation
  DemanderEntrer!_: ‚àÖ
  DemanderSortir!_: ‚àÖ
  Entrer!_: Si on est au moins 4 a attendre d'entrer, ou si qqn a aussi demand√© √† sortir
  Sortir!_: Si on est au moins 4 a attendre de sortir, ou si qqn a aussi demand√© √† entrer

3- Variables d'√©tat
  int nbAE: nombre en attente entr√©e
  int nbAS: nombre en attente sortie

 - Traduction des CA en language math√©matique
  DemanderEntrer!_: ‚àÖ
  DemanderSortir!_: ‚àÖ
  Entrer!_: nbAE ‚â• 4 | nbAS ‚â• 1
  Sortir!_: nbAS ‚â• 4 | nbAE ‚â• 1

4- Canaux
code bridget
*[
  DemanderEntrer?_ -> mbAE++;
  üûé
  DemanderSortir?_ -> mbAS++;
  üûé
  (NbAE ‚â• 1 & nbAS ‚â• 1) -> {
    Entrer?_
    Sortir?_
    nbAE--
    nbAS--
  }
  üûé
  (NbAE ‚â• 4) -> {
    Entrer?_; Entrer?_; Entrer?_; Entrer?_
    nbAE-=4
  }
  (NbAS ‚â• 4) -> {
    Sortir?_; Sortir?_; Sortir?_; Sortir?_
    nbAS-=4
  }
]

 ‚§π‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïåSSSSS‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚îê
0,0 -ds-> 0,1 -ds-> 0,2 -ds-> 0,3 -ds-> 0,4
 |
 de
1,0 -ds-> 1,1 -ds-> 0,1 ....

(Automate non compl√©t√©...)

