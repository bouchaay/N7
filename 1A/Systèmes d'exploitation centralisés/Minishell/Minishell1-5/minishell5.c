/* Auteur : Ayoub Bouchama
 * Groupe : F
 * Minishell
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include "readcmd.h"

/* Le répertoire courant */
char *RepertoireCourant;
/* La ligne de commande saisie */
struct cmdline *cmd;

/* Fonction qui lit une ligne de commande. */
void lirecmd() {
    do {
        RepertoireCourant = malloc(100 * sizeof(char));
        strcpy(RepertoireCourant, getcwd(NULL, 0));
        printf("\n%s", RepertoireCourant);
        printf("> ");
        fflush(stdout);
        cmd = readcmd();
    } while (cmd->seq[0] == NULL);
}

/* Fonction cd qui change le répertoire courant. */
void cd(char *path) {
    if (path == NULL) {
        chdir(getenv("HOME"));
    } else {
        chdir(path);
    }
}

/* Fonction principale. */
int main(int argc, char **argv) {

    while (1) {
        lirecmd();
        if (strcmp(cmd->seq[0][0], "exit") == 0) {
            break;
        }
        if (strcmp(cmd->seq[0][0], "cd") == 0) {
            cd(cmd->seq[0][1]);
        } else {
            pid_t pid = fork();
            if (pid == -1) {
                perror("fork");
                exit(1);
            } else if (pid == 0) {
                if (cmd->backgrounded != NULL) {
                    pid_t pid_bg = fork();
                    if (pid_bg == -1) {
                        perror("fork");
                        exit(1);
                    } else if (pid_bg == 0) {
                        execvp(cmd->seq[0][0], cmd->seq[0]);
                        perror("execvp");
                        exit(1);
                    } else {
                        printf("pid du processus en arrière plan : %d\n", pid_bg);
                    }
                } else {
            	    execvp(cmd->seq[0][0], cmd->seq[0]);
            	    perror("execvp");
            	    exit(1);
                }
            } else {
                int status;
                waitpid(pid, &status, 0);
            }
        }
    }
    free(RepertoireCourant);
    return EXIT_SUCCESS;
}
