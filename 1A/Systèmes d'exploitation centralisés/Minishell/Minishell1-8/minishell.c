/* Auteur : Ayoub Bouchama
 * Groupe : F
 * Minishell Version Intermédiaire
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include "readcmd.h"
#include "job.h"
#include <signal.h>

#define UID_START 1000

/* Le répertoire courant */
char *RepertoireCourant;
/* La ligne de commande saisie */
struct cmdline *cmd;
/* La table des jobs */
jobsTable *jt;
/* Compeur pour les UIDs */
int COMPTEUR_UID = 0;

/* Fonction qui lit une ligne de commande. */
void lirecmd() {
    do {
        RepertoireCourant = malloc(100 * sizeof(char));
        strcpy(RepertoireCourant, getcwd(NULL, 0));
        printf("\033[31m\033[1m\n%s\033[0m", RepertoireCourant);
	printf("\033[1m> \033[0m");
        fflush(stdout);
        cmd = readcmd();
    } while (cmd->seq[0] == NULL);
}

/* Fonction cd qui change le répertoire courant. */
void cd(char *path) {
    if (path == NULL || strcmp(path, "~") == 0) {
        chdir(getenv("HOME"));
    } else {
        chdir(path);
    }
}

/* Fonction qui retourne la commande saisie. */
char *getCmd(struct cmdline *cmd) {
    char *cmdLine = malloc(100 * sizeof(char));
    cmdLine[0] = '\0'; // initialiser la chaîne de caractères à une chaîne vide
    int i = 0;
    while (cmd->seq[0][i] != NULL) {
        strcat(cmdLine, cmd->seq[0][i]);
        strcat(cmdLine, " ");
        i++;
    }
    return cmdLine;
}

/* Fonction qui retourne l'état du processus. */
int etat_processus(pid_t pid) {
    int ret = kill(pid, 0);
    if (ret == 0) {
        // Le processus existe, on envoie un signal SIGCONT pour tester son état
        ret = kill(pid, SIGCONT);
        if (ret == 0) {
            // Le signal a été envoyé avec succès, le processus est actif
            return 1;
        }
    }
    return 0;
}

/* Mettre à jour l'état des jobs. */
void mise_a_jour(jobsTable *jt) {
    Cellule *c = jt->tete;
    while (c != NULL) {
        if (etat_processus(c->job->PID) == 0) {
            c->job->STAT = SUSPENDU;
        }
        c = c->suivant;
    }
}

/* Handler du signal CTRL+Z. */
void handler_SIGTSTP(int sig) {
    mise_a_jour(jt);
    Cellule *c = jt->tete;
    printf("CTRL+Z appuiyé");
    while (c != NULL) {
        if (c->job->STAT == ACTIF && c->job->PPID == getpid()) {
            kill(c->job->PID, SIGSTOP);
            c->job->STAT = SUSPENDU;
            break;
        }
        c = c->suivant;
    }
}

/* Handler du signal CTRL+C. */
void handler_SIGINT(int sig) {
    mise_a_jour(jt);
    Cellule *c = jt->tete;
    printf("CTRL+C appuiyé");
    while (c != NULL) {
        if (c->job->STAT == ACTIF && c->job->PPID == getpid()) {
            kill(c->job->PID, SIGINT);
            break;
        }
        c = c->suivant;
    }
}

/* Suspendre le minishell et lui seul. */
void susp() {
    printf("Minishell en cours de suspension...\n");
    sleep(2);
    kill(getpid(), SIGSTOP);
}

/* Fonction principale. */
int main() {
    // Initialisation de la table des jobs.
    jobsTable *jt = malloc(sizeof(jobsTable));
    initialiser_jobTable(jt);

    // Initialisation du handler du signal CTRL+Z.
    struct sigaction actionCTRLZ;
    actionCTRLZ.sa_handler = handler_SIGTSTP;
    sigemptyset(&actionCTRLZ.sa_mask);
    actionCTRLZ.sa_flags = 0;
    sigaction(SIGTSTP, &actionCTRLZ, NULL);

    // Initialisation du handler du signal CTRL+C.
    struct sigaction actionCTRLC;
    actionCTRLC.sa_handler = handler_SIGINT;
    sigemptyset(&actionCTRLC.sa_mask);
    actionCTRLC.sa_flags = 0;
    sigaction(SIGINT, &actionCTRLC, NULL);

    while (1) {
        // Lecture de la commande.
        lirecmd();

        if (strcmp(cmd->seq[0][0], "exit") == 0) {
            // Quitter le shell.
            break;
        } else if (strcmp(cmd->seq[0][0], "cd") == 0) {
            // Changer le répertoire courant.
            cd(cmd->seq[0][1]);
        } else if (strcmp(cmd->seq[0][0], "susp") == 0) {
            // vide la table des jobs
            vider_jobTable(jt);
            // Suspendre le minishell.
            susp();
        } else if (strcmp(cmd->seq[0][0], "lj") == 0) {
            // Afficher la liste des jobs et ajouter la nouvelle commande à la table des jobs.
            afficher_jobs(jt);
        } else if (strcmp(cmd->seq[0][0], "sj") == 0) {
            // Suspension du job.
            int uid_sj = atoi(cmd->seq[0][1]);
            suspendre_job(jt, uid_sj);
        } else if (strcmp(cmd->seq[0][0], "bg") == 0) {
            // Exécution en arrière-plan du job.
            int uid_bg = atoi(cmd->seq[0][1]);
            reprendre_job_en_arriere_plan(jt, uid_bg);
        } else if (strcmp(cmd->seq[0][0], "fg") == 0) {
            // Exécution en avant-plan du job.
            int uid_fg = atoi(cmd->seq[0][1]);
            reprendre_job_en_avant_plan(jt, uid_fg);
        } else {
            // Exécuter la commande.
            pid_t pid = fork();
            if (pid == -1) {
                // Erreur lors de la création du processus fils.
                perror("fork");
                exit(1);
            } else if (pid == 0) {
                // Processus fils.
                if (cmd->backgrounded != NULL) {
                    // Si la commande est en arrière-plan, créer un nouveau processus fils pour l'exécuter.
                    pid_t pid_bg = fork();
                    if (pid_bg == -1) {
                        // Erreur lors de la création du processus fils pour l'exécution en arrière-plan.
                        perror("fork");
                        exit(1);
                    } else if (pid_bg == 0) {
                        // Processus fils pour l'exécution en arrière-plan.
                        ajouter_job(jt, COMPTEUR_UID + UID_START, getpid(), getppid(), SUSPENDU, getCmd(cmd));
                        COMPTEUR_UID++;
                        execvp(cmd->seq[0][0], cmd->seq[0]);
                        // Erreur lors de l'exécution de la commande.
                        perror("execvp");
                        exit(1);
                    } else {
                        // Afficher le PID du processus en arrière-plan.
                        printf("pid du processus en arrière plan : %d\n", pid_bg);
                        ajouter_job(jt, COMPTEUR_UID + UID_START, pid_bg, getpid(), ACTIF, getCmd(cmd));
                	COMPTEUR_UID++;
                      
                    }
                } else {
                    // Processus fils pour l'exécution en avant-plan.
                    ajouter_job(jt, COMPTEUR_UID + UID_START, getpid(), getppid(), SUSPENDU, getCmd(cmd));
                    COMPTEUR_UID++;
                    execvp(cmd->seq[0][0], cmd->seq[0]);
                    // Erreur lors de l'exécution de la commande.
                    perror("execvp");
                    exit(1);
                }
            } else {
                // Processus père.
                int status;
                waitpid(pid, &status, 0);
                ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), ACTIF, getCmd(cmd));
                COMPTEUR_UID++;
            }
            // Mise à jour de la table des jobs après l'exécution de la commande.
            mise_a_jour(jt);
        }
    }
    return EXIT_SUCCESS;
}
