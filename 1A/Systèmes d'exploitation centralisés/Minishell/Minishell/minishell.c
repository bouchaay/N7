/* Auteur : Ayoub Bouchama
 * Groupe : F
 * Minishell
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/wait.h>
#include "readcmd.h"
#include "job.h"
#include <signal.h>
#include "display.h"

#define UID_START 1000

/* Le répertoire courant */
char *RepertoireCourant;
/* La ligne de commande saisie */
struct cmdline *cmd;
/* La table des jobs */
jobsTable *jt;
/* Compeur pour les UIDs */
int COMPTEUR_UID = 0;
/* Le pid du processus fils */
pid_t pid;
/* Statut du processus */
int status;
/* Handler du signal CTRL+Z. */
struct sigaction actionCTRLZ;
/* Handler du signal CTRL+C. */
struct sigaction actionCTRLC;


/* Fonction qui lit une ligne de commande. */
void lirecmd() {
    do {
        RepertoireCourant = malloc(100 * sizeof(char));
        strcpy(RepertoireCourant, getcwd(NULL, 0));
        printf("\033[31m\033[1m\n%s\033[0m", RepertoireCourant);
	printf("\033[1m> \033[0m");
        fflush(stdout);
        cmd = readcmd();
    } while (cmd->seq[0] == NULL);
}

/* Fonction cd qui change le répertoire courant. */
void cd(char *path) {
    if (path == NULL || strcmp(path, "~") == 0) {
        chdir(getenv("HOME"));
    } else {
        chdir(path);
    }
}

/* Fonction qui retourne la commande saisie. */
char *getCmd(struct cmdline *cmd) {
    char *cmdLine = malloc(100 * sizeof(char));
    cmdLine[0] = '\0'; // initialiser la chaîne de caractères à une chaîne vide
    int i = 0;
    while (cmd->seq[0][i] != NULL) {
        strcat(cmdLine, cmd->seq[0][i]);
        strcat(cmdLine, " ");
        i++;
    }
    return cmdLine;
}

/* Fonction qui retourne l'état du processus. */
/* Vérifie si le processus est actif, suspendu ou terminé. */
int etat_processus(pid_t pid) {
    int status;
    // Si le processus est actif.
    if (waitpid(pid, &status, WNOHANG) == 0) {
        return 1;
    // si le processus est suspendu.
    } else if (WIFSTOPPED(status)) {
        return 0;
    // si le processus est terminé.
    } else {
        return -1;
    }
}

/* Mettre à jour l'état des jobs. */
void mise_a_jour(jobsTable *jt) {
    Cellule *c = jt->tete;
    while (c != NULL) {
        int etat = etat_processus(c->job->PID);
        if (etat == 1) {
            c->job->STAT = ACTIF;
        } else if (etat == 0) {
            c->job->STAT = SUSPENDU;
        } else {
            supprimer_job(jt, c->job->PID);
        }
        c = c->suivant;
    }
}

/* Handler du signal CTRL+Z. */
void handler_SIGTSTP(int sig) {
    kill(pid, SIGSTOP);
    mise_a_jour(jt);
}

/* Handler du signal CTRL+C. */
void handler_SIGINT(int sig) {
    kill(pid, SIGKILL);
    supprimer_job(jt, pid);
    mise_a_jour(jt);
}

/* Suspendre le minishell et lui seul. */
void susp() {
    printf("Minishell en cours de suspension...\n");
    sleep(2);
    kill(getpid(), SIGSTOP);
}

/* Initialiser le handler des signaux CTRL+Z et CTRL+C. */
void InitialiserHandler() {
    // Initialisation du handler du signal CTRL+Z.
    actionCTRLZ.sa_handler = handler_SIGTSTP;
    sigemptyset(&actionCTRLZ.sa_mask);
    actionCTRLZ.sa_flags = 0;
    sigaction(SIGTSTP, &actionCTRLZ, NULL);

    // Initialisation du handler du signal CTRL+C.
    actionCTRLC.sa_handler = handler_SIGINT;
    sigemptyset(&actionCTRLC.sa_mask);
    actionCTRLC.sa_flags = 0;
    sigaction(SIGINT, &actionCTRLC, NULL);
}

/* Fonction principale. */
int main() {
    // Initialisation de la table des jobs.
    jobsTable *jt = malloc(sizeof(jobsTable));
    initialiser_jobTable(jt);

    // Initialisation du handler du signal CTRL+Z.
    InitialiserHandler();

    while (1) {
        // Lecture de la commande.
        lirecmd();

        // Gestion des commandes internes et externes.
        if (strcmp(cmd->seq[0][0], "exit") == 0) {
            // Quitter le shell.
            break;
        } else if (strcmp(cmd->seq[0][0], "cd") == 0) {
            // Changer le répertoire courant.
            cd(cmd->seq[0][1]);
        } else if (strcmp(cmd->seq[0][0], "susp") == 0) {
            // vide la table des jobs
            vider_jobTable(jt);
            // Suspendre le minishell.
            susp();
        } else if (strcmp(cmd->seq[0][0], "lj") == 0) {
            // Afficher la liste des jobs et ajouter la nouvelle commande à la table des jobs.
            afficher_jobs(jt);
        } else if (strcmp(cmd->seq[0][0], "sj") == 0) {
            // Suspension du job.
            int uid_sj = atoi(cmd->seq[0][1]);
            suspendre_job(jt, uid_sj);
        } else if (strcmp(cmd->seq[0][0], "bg") == 0) {
            // Exécution en arrière-plan du job.
            int uid_bg = atoi(cmd->seq[0][1]);
            reprendre_job_en_arriere_plan(jt, uid_bg);
        } else if (strcmp(cmd->seq[0][0], "fg") == 0) {
            // Exécution en avant-plan du job.
            int uid_fg = atoi(cmd->seq[0][1]);
            reprendre_job_en_avant_plan(jt, uid_fg);
        } else {
            // Exécuter la commande.
            pid = fork();
            if (pid == -1) {
                // Erreur lors de la création du processus fils.
                perror("fork");
                exit(1);
            } else if (pid == 0) {
                // Processus fils.
                ajouter_job(jt, COMPTEUR_UID + UID_START, getpid(), getppid(), ACTIF, getCmd(cmd));
                COMPTEUR_UID++;
                mise_a_jour(jt);
                int fd;

                // Gestion des redirections.
                if ((cmd->in != NULL) || (cmd->out != NULL)) {
                    if (cmd->in != NULL) {
                        fd = open(cmd->in, O_RDONLY);
                        if (fd == -1) {
                            perror("Erreur lors de l'ouverture du fichier");
                            exit(1);
                        }
                        // Redirection de l'entrée standard.
                        if (dup2(fd, 0) == -1) {
                            perror("Erreur lors de la redirection");
                            exit(1);
                        }
                        // Fermer le fichier.
                        if (close(fd) == -1) {
                            perror("Erreur lors de la fermeture du fichier");
                            exit(1);
                        }
                    }
                    if (cmd->out != NULL) {
                        fd = open(cmd->out, O_RDWR | O_CREAT | O_TRUNC, 0640);
                        if (fd == -1) {
                            perror("Erreur lors de l'ouverture du fichier");
                            exit(1);
                        }
                        // Redirection de la sortie standard.
                        if (dup2(fd, 1) == -1) {
                            perror("Erreur lors de la redirection");
                            exit(1);
                        }
                        // Fermer le fichier.
                        if (close(fd) == -1) {
                            perror("Erreur lors de la fermeture du fichier");
                            exit(1);
                        }
                    }
                    ajouter_job(jt, COMPTEUR_UID + UID_START, getpid(), getppid(), ACTIF, getCmd(cmd));
                    execvp(cmd->seq[0][0], cmd->seq[0]);
                    perror("execvp");
                    exit(1);
                // Tubes
                } else if (cmd->seq[1] != NULL) {
                    int tube[2];
                    if (pipe(tube) == -1) {
                        perror("pipe");
                        exit(1);
                    }
                    pid_t pid2 = fork();
                    if (pid2 == -1) {
                        perror("fork");
                        exit(1);
                    } else if (pid2 == 0) {
                        // Processus fils.
                        close(tube[0]);
                        dup2(tube[1], 1);
                        close(tube[1]);
                        ajouter_job(jt, COMPTEUR_UID + UID_START, getpid(), getppid(), ACTIF, getCmd(cmd));
                        execvp(cmd->seq[0][0], cmd->seq[0]);
                        perror("execvp");
                        exit(1);
                    } else {
                        // Processus père.
                        close(tube[1]);
                        dup2(tube[0], 0);
                        close(tube[0]);
                        execvp(cmd->seq[1][0], cmd->seq[1]);
                        perror("execvp");
                        exit(1);
                    }
                } else {
                    execvp(cmd->seq[0][0], cmd->seq[0]);
                    perror("execvp");
                    exit(1);
                }
            } else {
                // Processus père.
                if (cmd->backgrounded == NULL) {
                    // Processus père pour l'exécution en avant-plan.
                    waitpid(pid, &status, 0);
                }
            }
            // Mise à jour de la table des jobs après l'exécution de la commande.
            mise_a_jour(jt);
        }
    }
    return EXIT_SUCCESS;
}
