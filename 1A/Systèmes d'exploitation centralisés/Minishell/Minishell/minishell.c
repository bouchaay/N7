/* Auteur : Ayoub Bouchama
 * Groupe : F
 * Minishell
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/wait.h>
#include "readcmd.h"
#include "job.h"
#include <signal.h>
#include <errno.h>

#define UID_START 1000

/* Le répertoire courant */
char *RepertoireCourant;
/* La ligne de commande saisie */
struct cmdline *cmd;
/* La table des jobs */
jobsTable *jt;
/* Compeur pour les UIDs */
int COMPTEUR_UID = 0;
/* Le pid du processus fils */
pid_t pid;
/* Dernier pid de l'avant plan */
pid_t last_pid;
/* Statut du processus */
int status;
/* Descripteur de fichier */
int fd;
/* Sigaction de SIGINT */
struct sigaction sigint;
/* Sigaction de SIGTSTP */
struct sigaction sigtstp;
/* Nombre de commandes */
int nb_cmd;

/* Fonction qui lit une ligne de commande. */
void lirecmd() {
    do {
        RepertoireCourant = malloc(100 * sizeof(char));
        strcpy(RepertoireCourant, getcwd(NULL, 0));
        printf("\033[31m\033[1m\n%s\033[0m", RepertoireCourant);
	    printf("\033[1m> \033[0m");
        fflush(stdout);
        cmd = readcmd();
    } while (cmd->seq[0] == NULL);
}

/* Fonction qui efface l'écran. */
void clear_screen() {
    system("clear");
}

/* Fonction cd qui change le répertoire courant.
 * @param path : le chemin du répertoire. 
 */
void cd(char *path) {
    if (path == NULL || strcmp(path, "~") == 0) {
        chdir(getenv("HOME"));
    } else {
        chdir(path);
    }
}

/* Fonction qui retourne la commande saisie.
 * @param cmd : la ligne de commande saisie.
 */
char *getCmd(struct cmdline *cmd) {
    char *cmdLine = malloc(100 * sizeof(char));
    cmdLine[0] = '\0'; // initialiser la chaîne de caractères à une chaîne vide
    int i = 0;
    while (cmd->seq[0][i] != NULL) {
        strcat(cmdLine, cmd->seq[0][i]);
        strcat(cmdLine, " ");
        i++;
    }
    return cmdLine;
}

char* CommandeElementairePipe(struct cmdline *cmd, int indice) {
    char *cmdLine = malloc(100 * sizeof(char));
    cmdLine[0] = '\0'; // initialiser la chaîne de caractères à une chaîne vide
    int i = 0;
    while (cmd->seq[indice][i] != NULL) {
        strcat(cmdLine, cmd->seq[indice][i]);
        strcat(cmdLine, " ");
        i++;
    }
    return cmdLine;
}

/* Mettre à jour l'état des jobs. */
void mise_a_jour() {
    int codeTerminaison;
    pid_t filsid;
    while ((filsid = waitpid(-1, &codeTerminaison, WNOHANG)) > 0) {
        if (WIFSIGNALED(codeTerminaison)) {
            if (WTERMSIG(codeTerminaison) == SIGINT) {
                ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), TERMINE, getCmd(cmd));
            } else if (WTERMSIG(codeTerminaison) == SIGTSTP) {
                ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), SUSPENDU, getCmd(cmd));
            }
        } else if (WIFEXITED(codeTerminaison)) {
            changer_etat(jt, filsid, TERMINE);
        } else if (WIFSTOPPED(codeTerminaison)) {
            changer_etat(jt, filsid, SUSPENDU);
        } else if (WIFCONTINUED(codeTerminaison)) {
            changer_etat(jt, filsid, ACTIF);
        }
    }
}

/* Handler du signal CTRL+Z.
 * @param sig : le signal.
 */
void handler_SIGTSTP(int sig) {
    kill(last_pid, SIGTSTP);
}

/* Handler du signal CTRL+C.
 * @param sig : le signal.
 */
void handler_SIGINT(int sig) {
    kill(last_pid, SIGINT);
}

/* Suspendre le minishell et lui seul. */
void susp() {
    printf("Minishell en cours de suspension...\n");
    sleep(2);
    kill(getpid(), SIGSTOP);
}

/* Fonction qui exécute une commande avec un pipeline.
 * @param cmd : la ligne de commande saisie.
 * @param fd_precedent : le descripteur de fichier.
 * @param indice : l'indice de la commande.
 */
void executer_pipeline(struct cmdline *cmd, int fd_precedent, int indice) {

    nb_cmd = 0;

    /* Dernière commande du pipeline. */
    if (cmd->seq[indice+1] == NULL) {

        /* Incrémenter le nombre de commandes. */
        nb_cmd++;

        /* Redirection de la sortie standard si la dernière commande du pipeline. */
        if (cmd->out != NULL) {

            /* Ouvrir le fichier. */
            fd = open(cmd->out, O_RDWR | O_CREAT | O_TRUNC, 0640);
            if (fd == -1) {
                perror("Erreur lors de l'ouverture du fichier");
                exit(1);
            }

            /* Redirection de la sortie standard. */
            if (dup2(fd, 1) == -1) {
                perror("Erreur lors de la redirection");
                exit(1);
            }

            /* Fermer le fichier. */
            if (close(fd) == -1) {
                perror("Erreur lors de la fermeture du fichier");
                exit(1);
            }
        }

        /* Redirection de l'entrée standard. */
	    if (dup2(fd_precedent, 0) == -1) {
            perror("Erreur lors de la redirection");
            exit(1);
	    }

	    /* Fermer le descripteur de fichier. */
	    if (close(fd_precedent) < 0) {
	        perror("Erreur lors de la fermeture du descripteur de fichier");
	        exit(1);
	    }

        /* Création du processus fils. */
        pid_t last_pipe_fils;
        last_pipe_fils = fork();

        /* Erreur lors de la création du processus fils. */
        if (last_pipe_fils < 0) {
            perror("Erreur lors de la création du processus fils");
            exit(1);

        /* Processus fils. */
        } else if (last_pipe_fils == 0) {
            
            /* Exécution de la commande. */
	        execvp(cmd->seq[indice][0], cmd->seq[indice]);
            perror("Erreur lors de l'exécution de la commande");
	        exit(1);

        /* Processus père. */
        } else {
            ajouter_job(jt, COMPTEUR_UID + UID_START, last_pipe_fils, getpid(), TERMINE, CommandeElementairePipe(cmd, nb_cmd-1));
            COMPTEUR_UID++;
            waitpid(last_pipe_fils, &status, 0);
        }
    /* Pipeline. */
    } else { 
        
        /* Redirection de l'entrée standard si le premier tube. */
        if (indice == 0 && cmd->in != NULL) {
            /* Ouvrir le fichier. */
            fd = open(cmd->in, O_RDONLY);
                if (fd == -1) {
                    perror("Erreur lors de l'ouverture du fichier");
                    exit(1);
                }

            /* Redirection de l'entrée standard. */
            if (dup2(fd, 0) == -1) {
                perror("Erreur lors de la redirection");
                exit(1);
            }

            /* Fermer le fichier. */
            if (close(fd) == -1) {
                perror("Erreur lors de la fermeture du fichier");
                exit(1);
            }
        }

        /* Création du processus fils. */
	    pid_t fils;
	    int pipe_2[2];

	    /* Création du pipe. */
	    if (pipe(pipe_2) == -1) {
	        perror("Erreur lors de la création du pipe");
            exit(1);
        }

	    /* Création du processus fils. */
	    fils = fork();

	    /* Erreur lors de la création du processus fils. */
	    if (fils < 0) {
	        perror("Erreur lors de la création du processus fils");
	        exit (1);

	    /* Processus fils. */
	    } else if (fils == 0) {
	    
            /* Fermer le descripteur de fichier. */
	        if (close(pipe_2[0]) < 0) {
		        perror("Erreur lors de la fermeture du descripteur de fichier");
		        exit(1);
	        }

	        /* Redirection de l'entrée standard. */
	        if (dup2(fd_precedent, 0) == -1) {
		        perror ("Erreur lors de la redirection");
		        exit (1);
	        }

	        /* Fermer le descripteur de fichier. */
	        if (close(fd_precedent) < 0) {
		        perror("Erreur lors de la fermeture du descripteur de fichier");
		        exit(1);
	        }

	        /* Redirection de la sortie standard. */
	        if (dup2 (pipe_2[1], 1) == -1) {
		        perror ("Erreur lors de la redirection");
		        exit (1);
	        }

	        /* Exécution de la commande. */
	        if (execvp(cmd->seq[indice][0], cmd->seq[indice]) == -1) {
                perror("Erreur lors de l'exécution de la commande");
                exit(1);
            }
	        exit(0);

	    /* Processus père. */
	    } else {

            /* Incrémenter le nombre de commandes. */
            nb_cmd++;

	        /* Fermer le descripteur de fichier. */
	        if (close(pipe_2[1]) < 0) {
		        perror("Erreur lors de la fermeture du descripteur de fichier");
		        exit(1);
	        }

            /* Ajour de la commande à la table des jobs. */
            ajouter_job(jt, COMPTEUR_UID + UID_START, fils, getpid(), ACTIF, CommandeElementairePipe(cmd, nb_cmd-1));
            COMPTEUR_UID++;

            /* Attendre la fin du processus fils. */
            waitpid(fils, &status, 0);

	        /* Exécution le reste du pipeline récursivement. */
	        executer_pipeline(cmd, pipe_2[0], indice+1);
	    }
    }
}

/* Fonction principale. */
int main() {

    /* Initialisation de la table des jobs. */
    jt = malloc(sizeof(jobsTable));
    initialiser_jobTable(jt);

    /* Traitant du signal CTRL+Z. */
    sigtstp.sa_handler = handler_SIGTSTP;
    sigemptyset(&sigtstp.sa_mask);
    sigtstp.sa_flags = 0;
    sigaction(SIGTSTP, &sigtstp, NULL);
    

    /* Traitant du signal CTRL+C. */
    sigint.sa_handler = handler_SIGINT;
    sigemptyset(&sigint.sa_mask);
    sigint.sa_flags = 0;
    sigaction(SIGINT, &sigint, NULL);

    /* Boucle principale. */
    while (1) {
        
        /* Lire une ligne de commande. */
        lirecmd();

        /* Commande exit. */
        if (strcmp(cmd->seq[0][0], "exit") == 0) {
            break;

        /* Commande clear. */
        } else if (strcmp(cmd->seq[0][0], "clear") == 0) {
            clear_screen();

        /* Commande cd. */
        } else if (strcmp(cmd->seq[0][0], "cd") == 0) {
            cd(cmd->seq[0][1]);

        /* Commande susp. */
        } else if (strcmp(cmd->seq[0][0], "susp") == 0) {
            vider_jobTable(jt);
            susp();

        /* Commande fg. */
        } else if (strcmp(cmd->seq[0][0], "lj") == 0) {
            mise_a_jour(jt);
            afficher_jobs(jt);

        /* Commande sj. */
        } else if (strcmp(cmd->seq[0][0], "sj") == 0) {
            int uid_sj = atoi(cmd->seq[0][1]);
            suspendre_job(jt, uid_sj);

        /* Commande bg. */
        } else if (strcmp(cmd->seq[0][0], "bg") == 0) {
            int uid_bg = atoi(cmd->seq[0][1]);
            reprendre_job_en_arriere_plan(jt, uid_bg);

        /* Commande fg. */
        } else if (strcmp(cmd->seq[0][0], "fg") == 0) {
            int uid_fg = atoi(cmd->seq[0][1]);
            reprendre_job_en_avant_plan(jt, uid_fg);

        /* Commande externe. */
        } else {

            /* Création du processus fils. */
            pid = fork();

            /* Erreur lors de la création du processus fils. */
            if (pid == -1) {
                perror("fork");
                exit(1);

            /* Processus fils. */
            } else if (pid == 0) {

                /* Masquer les signaux SIGINT et SIGTSTP. */
                sigset_t mask;
                sigemptyset(&mask);
                sigaddset(&mask, SIGINT);
                sigaddset(&mask, SIGTSTP);
                sigprocmask(SIG_BLOCK, &mask, NULL);

                /* Redirections */
                if (cmd->seq[1] == NULL) {

                    /* Redirection de l'entrée standard. */
                    if (cmd->in != NULL) {

                        /* Ouvrir le fichier. */
                        fd = open(cmd->in, O_RDONLY);
                        if (fd == -1) {
                            perror("Erreur lors de l'ouverture du fichier");
                            exit(1);
                        }

                        /* Redirection de l'entrée standard. */
                        if (dup2(fd, 0) == -1) {
                            perror("Erreur lors de la redirection");
                            exit(1);
                        }

                        /* Fermer le fichier. */
                        if (close(fd) == -1) {
                            perror("Erreur lors de la fermeture du fichier");
                            exit(1);
                        }
                    }

                    /* Redirection de la sortie standard. */
                    if (cmd->out != NULL) {

                        /* Ouvrir le fichier. */
                        fd = open(cmd->out, O_RDWR | O_CREAT | O_TRUNC, 0640);
                        if (fd == -1) {
                            perror("Erreur lors de l'ouverture du fichier");
                            exit(1);
                        }
                        
                        /* Redirection de la sortie standard. */
                        if (dup2(fd, 1) == -1) {
                            perror("Erreur lors de la redirection");
                            exit(1);
                        }
                        
                        /* Fermer le fichier. */
                        if (close(fd) == -1) {
                            perror("Erreur lors de la fermeture du fichier");
                            exit(1);
                        }
                    }

                    /* Exécution de la commande. */
                    execvp(cmd->seq[0][0], cmd->seq[0]);
                    perror("Erreur lors de l'exécution de la commande");
                    exit(1);

                /* Pipeline */
                } else {

                    /* Exécution de la commande. */
                    executer_pipeline(cmd, 0, 0);

                }
                
                /* Sortie du processus fils. */
                exit(0);

            /* Processus père. */
            } else {

                /* Attendre la fin du processus fils. */
                bool backgrounded = (cmd->backgrounded != NULL);
                if (!backgrounded) {
                    last_pid = pid;
                    waitpid(pid, &status, 0);

                    /* si le processus est terminé normalement, on le supprime de la table des jobs */
                    if (WIFEXITED(status)) {
                        ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), TERMINE, getCmd(cmd));
                    } else if (WIFSIGNALED(status)) {
                        // vérifier si le fils a été tué avec SIGINT
                        if (WTERMSIG(status) == SIGINT) {
                            changer_etat(jt, last_pid, TERMINE);
                        }
                        // vérifier si le fils a été tué avec SIGTSTP
                        if (WTERMSIG(status) == SIGTSTP) {
                            changer_etat(jt, last_pid, SUSPENDU);
                        }
                    }
                } else {
                    ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), ACTIF, getCmd(cmd));
                }

                /* Incrémenter le compteur des UIDs. */
                COMPTEUR_UID++;
            }

            /* Mise à jour de la table des jobs. */
            mise_a_jour();
        }
    }

    /* Sortie du minishell. */
    return EXIT_SUCCESS;
}
