/* Auteur : Ayoub Bouchama
 * Groupe : F
 * Minishell
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/wait.h>
#include "readcmd.h"
#include "job.h"
#include <signal.h>
#include "display.h"
#include <errno.h>

#define UID_START 1000

/* Le répertoire courant */
char *RepertoireCourant;
/* La ligne de commande saisie */
struct cmdline *cmd;
/* La table des jobs */
jobsTable *jt;
/* Compeur pour les UIDs */
int COMPTEUR_UID = 0;
/* Le pid du processus fils */
pid_t pid;
/* Dernier pid de l'avant plan */
pid_t last_pid;
/* Statut du processus */
int status;
/* Descripteur de fichier */
int fd;
/* Sigaction de SIGINT */
struct sigaction sigint;
/* Sigaction de SIGTSTP */
struct sigaction sigtstp;

/* Fonction qui lit une ligne de commande. */
void lirecmd() {
    do {
        RepertoireCourant = malloc(100 * sizeof(char));
        strcpy(RepertoireCourant, getcwd(NULL, 0));
        printf("\033[31m\033[1m\n%s\033[0m", RepertoireCourant);
	    printf("\033[1m> \033[0m");
        fflush(stdout);
        cmd = readcmd();
    } while (cmd->seq[0] == NULL);
}

/* Fonction cd qui change le répertoire courant.
 * @param path : le chemin du répertoire. 
 */
void cd(char *path) {
    if (path == NULL || strcmp(path, "~") == 0) {
        chdir(getenv("HOME"));
    } else {
        chdir(path);
    }
}

/* Fonction qui retourne la commande saisie.
 * @param cmd : la ligne de commande saisie.
 */
char *getCmd(struct cmdline *cmd) {
    char *cmdLine = malloc(100 * sizeof(char));
    cmdLine[0] = '\0'; // initialiser la chaîne de caractères à une chaîne vide
    int i = 0;
    while (cmd->seq[0][i] != NULL) {
        strcat(cmdLine, cmd->seq[0][i]);
        strcat(cmdLine, " ");
        i++;
    }
    return cmdLine;
}

/* Mettre à jour l'état des jobs. */
void mise_a_jour() {
    int codeTerminaison;
    pid_t filsid;
    while ((filsid = waitpid(-1, &codeTerminaison, WNOHANG)) > 0) {
        if (WIFEXITED(codeTerminaison)) {
            changer_etat(jt, filsid, TERMINE);
        } else if (WIFSIGNALED(codeTerminaison)) {
            if (WTERMSIG(codeTerminaison) == SIGINT) {
                changer_etat(jt, filsid, TERMINE);
            } else if (WTERMSIG(codeTerminaison) == SIGTSTP) {
                changer_etat(jt, filsid, SUSPENDU);
            }
        } else if (WIFSTOPPED(codeTerminaison)) {
            changer_etat(jt, filsid, SUSPENDU);
        } else if (WIFCONTINUED(codeTerminaison)) {
            changer_etat(jt, filsid, ACTIF);
        }
    }
}

/* Handler du signal CTRL+Z.
 * @param sig : le signal.
 */
void handler_SIGTSTP(int sig) {
    kill(last_pid, SIGTSTP);
}

/* Handler du signal CTRL+C.
 * @param sig : le signal.
 */
void handler_SIGINT(int sig) {
    kill(last_pid, SIGINT);
}

/* Suspendre le minishell et lui seul. */
void susp() {
    printf("Minishell en cours de suspension...\n");
    sleep(2);
    kill(getpid(), SIGSTOP);
}

/* Exécution des pipelines.
 * @param index : l'index de la commande dans le pipeline.
 * @param pipefd : le descripteur de fichier du pipe.
 * @param previous_read_fd : le descripteur de fichier de la lecture précédente.
 */
void executer_pipeline(int index, int pipefd[2], int previous_read_fd) {
    if (cmd->seq[index + 1] == NULL) {

        /* Dernière commande du pipeline. */
        dup2(previous_read_fd, 0);  /* Rediriger l'entrée vers la lecture précédente. */
        close(pipefd[0]);  /* Fermer le descripteur de lecture du pipe précédent. */

        /* Redirection de l'entrée standard. */
        if (cmd->out != NULL) {
            fd = open(cmd->out, O_RDWR | O_CREAT | O_TRUNC, 0640);
            if (fd == -1) {
                perror("Erreur lors de l'ouverture du fichier");
                exit(1);
            }
            dup2(fd, 1);  /* Rediriger la sortie vers le fichier. */
            close(fd);
        }
    } else {
        
        /* Commande intermédiaire du pipeline. */
        int next_pipefd[2];
        pipe(next_pipefd);

        dup2(previous_read_fd, 0);  /* Rediriger l'entrée vers la lecture précédente. */
        close(pipefd[0]);  /* Fermer le descripteur de lecture du pipe précédent. */

        dup2(next_pipefd[1], 1);  /* Rediriger la sortie vers l'écriture du pipe actuel. */
        close(next_pipefd[0]);  /* Fermer le descripteur de lecture du pipe actuel. */

        /* Appeler récursivement pour la commandes suivante. */
        executer_pipeline(index + 1, next_pipefd, previous_read_fd);
    }

    /* Exécution de la commande. */
    execvp(cmd->seq[index][0], cmd->seq[index]);
    perror("Erreur lors de l'exécution de la commande");
    exit(1);
}

/* Fonction principale. */
int main() {

    /* Initialisation de la table des jobs. */
    jt = malloc(sizeof(jobsTable));
    initialiser_jobTable(jt);

    /* Traitant du signal CTRL+Z. */
    sigtstp.sa_handler = handler_SIGTSTP;
    sigemptyset(&sigtstp.sa_mask);
    sigtstp.sa_flags = 0;
    sigaction(SIGTSTP, &sigtstp, NULL);
    

    /* Traitant du signal CTRL+C. */
    sigint.sa_handler = handler_SIGINT;
    sigemptyset(&sigint.sa_mask);
    sigint.sa_flags = 0;
    sigaction(SIGINT, &sigint, NULL);

    /* Boucle principale. */
    while (1) {
        
        /* Lire une ligne de commande. */
        lirecmd();

        /* Commande exit. */
        if (strcmp(cmd->seq[0][0], "exit") == 0) {
            break;

        /* Commande clear. */
        } else if (strcmp(cmd->seq[0][0], "clear") == 0) {
            clear_screen();

        /* Commande cd. */
        } else if (strcmp(cmd->seq[0][0], "cd") == 0) {
            cd(cmd->seq[0][1]);

        /* Commande susp. */
        } else if (strcmp(cmd->seq[0][0], "susp") == 0) {
            vider_jobTable(jt);
            susp();

        /* Commande fg. */
        } else if (strcmp(cmd->seq[0][0], "lj") == 0) {
            mise_a_jour(jt);
            afficher_jobs(jt);

        /* Commande sj. */
        } else if (strcmp(cmd->seq[0][0], "sj") == 0) {
            int uid_sj = atoi(cmd->seq[0][1]);
            suspendre_job(jt, uid_sj);

        /* Commande bg. */
        } else if (strcmp(cmd->seq[0][0], "bg") == 0) {
            int uid_bg = atoi(cmd->seq[0][1]);
            reprendre_job_en_arriere_plan(jt, uid_bg);

        /* Commande fg. */
        } else if (strcmp(cmd->seq[0][0], "fg") == 0) {
            int uid_fg = atoi(cmd->seq[0][1]);
            reprendre_job_en_avant_plan(jt, uid_fg);

        /* Commande externe. */
        } else {

            /* Création du processus fils. */
            pid = fork();

            /* Erreur lors de la création du processus fils. */
            if (pid == -1) {
                perror("fork");
                exit(1);

            /* Processus fils. */
            } else if (pid == 0) {

                /* Redirections */
                if (cmd->seq[1] == NULL) {

                    /* Redirection de l'entrée standard. */
                    if (cmd->in != NULL) {

                        /* Ouvrir le fichier. */
                        fd = open(cmd->in, O_RDONLY);
                        if (fd == -1) {
                            perror("Erreur lors de l'ouverture du fichier");
                            exit(1);
                        }

                        /* Redirection de l'entrée standard. */
                        if (dup2(fd, 0) == -1) {
                            perror("Erreur lors de la redirection");
                            exit(1);
                        }

                        /* Fermer le fichier. */
                        if (close(fd) == -1) {
                            perror("Erreur lors de la fermeture du fichier");
                            exit(1);
                        }
                    }

                    /* Redirection de la sortie standard. */
                    if (cmd->out != NULL) {

                        /* Ouvrir le fichier. */
                        fd = open(cmd->out, O_RDWR | O_CREAT | O_TRUNC, 0640);
                        if (fd == -1) {
                            perror("Erreur lors de l'ouverture du fichier");
                            exit(1);
                        }
                        
                        /* Redirection de la sortie standard. */
                        if (dup2(fd, 1) == -1) {
                            perror("Erreur lors de la redirection");
                            exit(1);
                        }
                        
                        /* Fermer le fichier. */
                        if (close(fd) == -1) {
                            perror("Erreur lors de la fermeture du fichier");
                            exit(1);
                        }
                    }

                    /* Exécution de la commande. */
                    execvp(cmd->seq[0][0], cmd->seq[0]);
                    perror("Erreur lors de l'exécution de la commande");
                    exit(1);

                /* Pipeline */
                } else {

                    /* Créer un nouveau pipe. */
                    int pipefd[2];
                    pipe(pipefd);

                    /* Exécution de la première commande. */
                    dup2(pipefd[1], 1);

                    /* Fermer le descripteur d'écriture du pipe. */
                    close(pipefd[0]);

                    /* Appeler récursivement pour les commandes suivantes. */
                    executer_pipeline(0, pipefd, 0);

                    /* Ajouter le job dans la table des jobs. */
                    ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), ACTIF, getCmd(cmd));
                }

            /* Processus père. */
            } else {

                /* Attendre la fin du processus fils. */
                bool backgrounded = (cmd->backgrounded != NULL);
                if (!backgrounded) {
                    last_pid = pid;
                    waitpid(pid, &status, 0);

                    /* si le processus est terminé normalement, on le supprime de la table des jobs */
                    if (WIFEXITED(status)) {
                        ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), TERMINE, getCmd(cmd));
                    } else if (WIFSIGNALED(status)) {
                        // vérifier si le fils a été tué avec SIGINT
                        if (WTERMSIG(status) == SIGINT) {
                            changer_etat(jt, last_pid, TERMINE);
                        }
                        // vérifier si le fils a été tué avec SIGTSTP
                        if (WTERMSIG(status) == SIGTSTP) {
                            changer_etat(jt, last_pid, SUSPENDU);
                        }
                    }
                } else {
                    ajouter_job(jt, COMPTEUR_UID + UID_START, pid, getpid(), ACTIF, getCmd(cmd));
                }

                /* Incrémenter le compteur des UIDs. */
                COMPTEUR_UID++;
            }

            /* Mise à jour de la table des jobs. */
            mise_a_jour(jt);
        }
    }
    return EXIT_SUCCESS;
}